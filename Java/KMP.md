# KMP

KMP算法的核心是一个被称为部分匹配表（Partial Matching Table）的数组。对于字符串"abababca"，它的PMT如下所示：
| Char:  | a | b | a | b | a | b | c | a |
|--------|---|---|---|---|---|---|---|---|
| Index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| Value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |

字符串的前缀指包含第一位字符且不包含最后一位字符的任意子字符串
字符串的后缀指不包含第一位字符且包含最后一位字符的任意子字符串。
有了以上的定义我们可以说明PMT中的值的意义。**PMT中的值是字符串的最长公共前后缀的长度**。

## 如何使用KMP加速字符串查找

有了上一节的定义后假设i指向的是字符串当前查找的位置，j指向的是模式串当前查找的位置。
假如当模式串在j位置处与字符串在i位置处不匹配了，那么字符串i之前的PMT[j - 1]位一定与模式字符串的0至PMT[j - 1]位是相同的。因为字符串在第i位失配，那么主字符串从第i-j位到第i位一定与模式字符串0到j这一段是完全相同的。所以这一段的匹配就可以省略，i不动，将j指向PMT[j - 1]位。

有了上面的思路，我们就可以使用PMT加速字符串的查找了。我们看到如果是在 j 位 失配，那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值，所以为了编程的方便， 我们不直接使用PMT数组，而是将PMT数组向后偏移一位。我们把新得到的这个数组称为next数组。下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行向右偏移时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。

| Char:  | a | b | a | b | a | b | c | a |
|--------|---|---|---|---|---|---|---|---|
| Index: | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| Value: | 0 | 0 | 1 | 2 | 3 | 4 | 0 | 1 |
| Next:  | -1| 0 | 0 | 1 | 2 | 3 | 4 | 0 |

具体的代码实现：

```java
public int searchStr(String s, String p) {
    // s是主字符串， p是模式字符串
    int i = 0, j = 0;
    int n = s.length(), m = p.length();
    // 获取查找表
    int[] next = nextTable(p);
    // 终止条件为i大于主字符串长度了，表示没有匹配模式字符串的子字符串。或者j > p了表示已经匹配到了第一个模式字符串，i - j就为出现的模式字符串在主字符串中的第一个索引。
    while (i < n && j < p) {
        if (j == -1 || s.charAt[i] == p.charAt[j]) {
            i++;
            j++
        } else {
            j = next[j];
        }
    }
    return j == p ? i - j : -1;
}
```

## 如何求出Next数组

求next数组的方式完全可以看成是字符串匹配，即将模式字符串看为主字符串，以模式字符串的前缀为目标字符串，一旦匹配成功，那么当前的next值就位匹配成功的字符串长度。

具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。

```java
private int[] nextTable(String s) {
    int[] next = new int[s.length()];
    next[0] = -1; // 右移一位
    netx[1] = 0; // 字符串长度为1时没有最长公共前后缀
    int i = 2, cn = 0; // i 指向当前要求的next值，cn指向当前要和前一个字符比对的下标
    while (i < s.length()) {
        if (s.charAt(i) == s.charAt(cn)) {
            next[i++] = next[++cn]; // 匹配到i++， j++
        } else if (cn > 0){
            cn = next[cn]; // 没有匹配到,cn指向前一位next的值
        } else { // 当cn指向next的第0位了说明没有匹配的，那么当前的next[i]没有公共前后缀，所以为0
            next[i++] = 0;
        }
    }
    return next;
}
```
