# Vue-深入组件

## 注册

一个Vue组件在使用前需要先被”注册“,这样Vue才能在渲染模板时找到其对应实现。组件注册有两种方式：全局注册和局部注册

### 全局注册

我们可以使用 Vue 应用实例的 .component() 方法，让组件在当前 Vue 应用中全局可用。

```js
import { createApp } from 'vue'

const app = createApp({})

app.component(
    // 注册的名字
    'MyComponent',
    // 组件的实现
    {
        /* ... */
    }
)
```

如果使用单文件组件，你可以注册被导入的.vue文件:

```js
import MyComponent from './App.vue'

app.component('MyComponent', MyComponent)
```

全局注册的组件可在此应用的任意组件的模板中使用：

### 局部注册

全局注册虽然很方便，但有以下几个问题：

1. 全局注册，但没有被使用的组件无法被在生产打包的时候被自动移除。如果你全局注册了一个组件，即使他没有被实际应用，它仍然会出现在打包后的JS文件中
2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件的时候，不太容易定位子组件的实现。和使用过多全局变量一样，这可能会影响应用长期可维护性。

相比之下，局部注册的组件需要在使用它的父组件中导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确。

在使用 `<script setup>` 的单文件组件中，导入的组件可以直接在模板中使用，无需注册：

```vue
<script setup>
import ComponentA from './ComponentA.vue'
</script>

<template>
<ComponentA />
</template>
```

### 组件名格式

在整个指引中，我们都使用PascalCase作为组件名的注册格式，这是因为：

1. PascalCase是合法的JavaScript标识符。这使得在JavaScript中导入和注册组件都很容易，同时IDE也能提供较好的自动补全。
2. PascalCase在模板中更明显地表明了这是一个Vue组件，而不是原生HTML元素。同时也能将Vue组件和自定义Component区分开来。

## Props

### Props声明

一个组件需要显式声明他所接受的props，这样Vue才能知道从外部传入的是哪些props，哪些是透传attribute。

在使用`<script setup>`的单文件组件中，props可以使用defineProps宏来声明

```vue
<script setup>
    const props = defineProps(['foo'])
console.log(props.foo)
</script>
```

## 事件

### 触发与监听事件

在组件的模板表达式中，可以直接使用$emit方法触发自定义事件
`<button @click="$emit('someEvent')">Click Me</button>`

父组件可以通过v-on（缩写为@）来监听事件：
`<MyComponent @some-event="callback" />`

### 声明触发的事件

组件可以显式的通过defineEmits()宏来声明它触发的事件：

```vue
<script setup>
    defineEmits(['inFocus', 'submit'])
</script>
```

我们在 `<template>` 中使用的 $emit 方法不能在组件的 `<script setup>` 部分中使用，但 defineEmits() 会返回一个相同作用的函数供我们使用：

```vue
<script setup>
    const emit = defineEmits(['inFocus', 'submit'])

    function buttonClick() {
        emit('submit')
    }
</script>
```

### 事件校验

和对props添加类型校验的方式类似，所有触发的事件也可以通过对象的形式来描述。

要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入emit的内容，返回一个布尔值来表明事件是否合法。

```vue
<script setup>
    const emit = defineEmits({
        // 没有校验
        click: null,

        // 校验submit事件
        submit: ({ email, password}) => {
            if (email && password) {
                return true
            } else {
                console.warn('Invalid submit event payload!')
                return false
            }
        }
    })

    function submitForm(email, password) {
        emit('submit', {email, password})
    }
</script>
```

## 组件v-model

### 基本用法

v-model可以在组件上实现双向绑定

```vue
<script setup>
    const model = defineModel()

    function update() {
        model.value++
    }
</script>

<template>
    <div>Parent bound v-model is: {{ model }}</div>
    <button @click="update">Increment</button>
</template>
```

父组件可以用v-model绑定一个值：
`<Child v-model ="countModel" />`

defineModel() 返回的值是一个ref。它可以像其他ref一样被访问以及修改，不过他能起到在父组件和当前变量之间的双向绑定作用：

- 它的 .value和父组件的v-model同步；
- 当它的子组件变更了，会触发父组件绑定的值一起更新。

这意味着你也可以用v-model把这个ref绑定到一个原生input元素上，在提供相同的v-model用法的同时轻松包装原生input元素：

```vue
<script>
    const model = defineModel()
</script>

<template>
    <input v-model = "model" />
</template>
```

### 底层机制

defineModel是一个遍历宏。编译器将其展开为以下内容：

- 一个名为modelValue的prop，本地ref的值与其同步；
- 一个名为update: modelValue的事件，当本地ref的值发生变更时触发。

### v-model的参数

组件上的v-model也可以接受一个参数：
`<MyComponent v-model:title="bookTitle" />`

在子组件中我们可以通过将字符串作为第一个参数传递给defineModel（）来支持相应的参数：

```vue
<script setup>
    const title = defineModel('title')
</script>

<template>
    <input type = "text" v-model="title" />
</template>
```

## 多个v-model绑定

我们可以在单个组件实例上创建多个v-model双向绑定。

组件上的每一个v-model都会同步不同的prop，而无需额外的选项：

```template
<Username
    v-model:first-name="first"
    v-model:last-name="last"
/>
```

```vue
<script setup>
    const firstName = defineModel('firstName')
    const lastName = defineModel('lastName')
</script>

<template>
    <input type="text" v-model="firstName" />
    <input type="text" v-model="lastName" />
</template>
```

## 处理v-model修饰符

我们创建一个自定义的修饰符capitalize，它会自动将v-model绑定输入的字符串值第一个字母转为大写：

`<MyComponent v-model.capitalize="myText" />`

通过像这样解构defineModel()的返回值，可以在子组件中访问添加到组件v-model的修饰符：

```vue
<script setup>
    const [model, modifiers] = defineModel()
    console.log(modifier) // { capitalize: true}
</script>

<template>
    <input type="text" v-model="model" />
</template>
```

为了能够基于修饰符选择性地调节值的读取和写入，我们可以给defineModel()传入get和set这两个选项。这两个选项在从模型引用中读取或者设置值的时候会收到当前的值，并且他们都应该返回一个处理过的值。

```vue
<script setup>
    const [model, modifiers] = defineModel({
        set(value) {
            if （modifiers.captialize) {
                return value.charAt(0).toUpperCase() + value.slice(1) 
            }
            return value
        }
    })
</script>

<template>
    <input type="text" v-model="model" />
</template>
```

## 透传Attributes

“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。

当一个组件以单个元素为根作渲染时，透传的attribute会自动被添加到根元素上。举例来说，假如我们有一个`<MyButton>`组件
`<button>Click Me</button>`

一个父组件使用了这个组件，并且传入了class：

`<MyButton class="large" />`

最后渲染出的DOM结果是：

`<button class="large">Click Me</button>`

这里，MyButton并没有将class声明为一个它所接受的prop，所以class被视作透传attribute，自动传到了MyButton的根元素上

### 对class和style的合并

如果一个子组件的根元素已经有了class或者style attribute，它会和从父组件上继承的值合并。

`<button class="btn">Click Me</button>`

则最后渲染出来的结果是:

`<button class="btn large">Click Me</button>`

### v-on监听器继承

同样的规则也适用于v-on事件监听器:

`<MyButton @click="onClick" />`

click监听器会被添加到MyButton的根元素，即那个原生button元素之上。当原生button被点击，会触发父组件的onClick方法。同样的，如果原生button元素自身也通过v-on绑定了一个事件监听器，则这个监听器和父组件继承的监听器都会被触发。

### 深层组件继承

有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下MyButton，让它在根节点上渲染BaseButton

`<BaseButton />`

此时MyButton接收的透传attribute会直接继续传给BaseButton

请注意：

1. 透传的attribute不会包含MyButton上声明过的props或是针对emits声明事件的v-on侦听函数，换句话说，声明过的props和侦听函数被MyButton“消费了”。
2. 透传的attribute若符合声明，也可以作为props传入BaseButton

### 多根节点Attributes继承

和单根节点组件有所不同，有着多个根节点的组件没有自动attribute的透传行为。如果$attr没有被显式绑定，将会抛出一个运行警告。

`<CustomLayout id="custom-layout" @click="changeValue" />`

如果customLayout有以下这样的多根节点模板，由于Vue不知道将attribute传到哪里，所以会抛出一个警告。

```js
<header>..</hearder>
<main>..</main>
<footer>..</footer>
```

如果$attr被显式绑定，则不会有警告：

```js
<header>..</hearder>
<main v-bind="$attr">..</main>
<footer>..</footer>
```

## 插槽slot

组件能够接受任意类型的JavaScript值作为props，但组件要如何接受模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让
子组件在它们的组件中渲染这些片段。

```js
<FancyButton>
    Click me!
</FancyButton>
```

而FancyButton的模板是这样的：

```js
<button class="fancy-btn">
    <slot></slot>
</button>
```

\<slot>元素是一个插槽出口(slot outlet),标识了父元素提供的插槽内容(slot content)将在哪里被渲染

通过使用插槽，FancyButton仅负责渲染外层的\<button>以及相应的样式，而其内部的内容由父组件提供。
理解插槽的另一种形式是通过和下面的JavaScript函数作类比，其概念是类似的：

```js
// 父元素传入插槽内容
FancyButton('Click me!')

// FancyButton在自己的模板中渲染插槽内容
function FancyButton(slotContent) {
    return `<button class="fancy-bin">
        ${slotContenet}
        </button>`
}
```

插槽内容可以是任意合法的模板内容，不局限于文本。我们可以传入多个元素，甚至是组件：

```js
<FancyButton>
    <span style="color:red">Click me!</span>
    <AwesomeIcon name="plus">
</FancyButton>
```

通过使用插槽，FancyButton组件更加灵活和具有可复用性。现在组件可以用在不同的地方渲染各异的内容，但同时还保证具有相同的样式。

### 渲染作用域

插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的：

```js
<span>{{ message }}</span>
<FancyButton>{{ message }}</FancyButton>
```

这里两个{{ message }}插值表达式渲染的内容都是一样的。

插槽无法访问自子组件的数据，Vue模板中的表达式只能访问其定义时所处的作用域，这和JavaScript的词法作用域的规则一致。换言之：

> 父组件模板中的表达式只能访问父组件的作用域;子组件的模板表达式只能访问子组件的作用域

### 默认内容

在外部没有提供任何内容的情况下，可以为插槽指定默认内容

```js
<button type="submit">
    <slot></slot>
</button>
```

如果我们想在父组件没有提供任何插槽内容时在\<button>内渲染”submit“，只需要将submit写在\<slot>标签间来作为默认内容：

```js
<button type="submit">
    <slot>
        Submit <!-- 默认内容 -->
    </slot>
</button>
```

### 具名插槽

```js
<div class="container">
    <header>
        <slot name="header"></slot>
    </header>
    <main>
        <slot></slot>
    </main>
    <footer>
        <slot name="footer"></slot>
    </footer>
</div>
```

slot插槽有一个特殊的attribute name可以用来给各个插槽分配唯一的ID，以确定每一处要渲染的内容。被称为
具名插槽，没有提供name的插槽出口会隐式的命名为default

### 条件插槽

有时需要根据插槽是否存在来渲染某些内容。

可以使用$slot属性与v-if来实现

```js
<template>
    <div class="card">
        <div v-if="$slot.header" class="card-header">
            <slot name="header" />
        </div>

        <div v-if="$slot.default" class="card-content">
            <slot />
        </div>

        <div v-if="$slot.footer" class="card-footer">
            <slot name="footer" />
        </div>
    </div>
</template>
```
